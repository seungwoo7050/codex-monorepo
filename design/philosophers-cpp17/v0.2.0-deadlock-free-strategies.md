# philosophers-cpp17 v0.2.0 – 교착 회피 전략 설계서

## 1. 목표
- v0.1.0의 교착 시나리오를 유지하면서도 deadlock-free 전략(ordered, waiter)을 추가한다.
- CLI에서 전략을 선택할 수 있게 하여 naive/ordered/waiter 동작을 비교한다.
- 실행 로그에 교착 감지 여부와 철학자별 식사 횟수를 요약해 사용자에게 전략 효과를 보여준다.

## 2. 범위
- 전략 선택: `--strategy naive|ordered|waiter` 추가, 기본값은 `naive`.
- 공통 파라미터는 v0.1.0과 동일하게 유지하되, 통계 요약을 위한 식사 횟수 기록을 확장한다.
- waiter 전략은 `N-1` 토큰 정책과 조건변수를 사용해 동시에 식사 준비를 하는 철학자 수를 제한한다.
- ordered 전략은 포크 인덱스를 정렬해 항상 낮은 번호→높은 번호 순으로 잠금한다.
- 출력: `[요약] 전략=...` 라인과 각 철학자의 `식사 횟수`를 함께 표시한다.

## 3. 외부 동작 / CLI
- 실행: `./philosophers [옵션]`
- 주요 옵션 (기본값):
  - `--strategy <naive|ordered|waiter>`: 사용 전략 (naive)
  - `--philosophers <N>`: 철학자 수 (5)
  - `--think-ms <ms>`: 생각 시간 (200)
  - `--eat-ms <ms>`: 식사 시간 (300)
  - `--lock-timeout-ms <ms>`: 포크 대기 시간 (800)
  - `--stuck-threshold-ms <ms>`: 교착 징후 감지 임계값 (700)
  - `--duration-ms <ms>`: 전체 실행 시간 (3000)
- 출력: 상태 로그 + 교착 안내(naive) + `[요약] 전략=...` + 철학자별 식사 횟수 + 종료 안내.

## 4. 내부 설계
- `SimulationConfig`
  - 기존 타이밍/개수 필드에 `strategy: StrategyType` 추가.
- `StrategyType`
  - `kNaive`, `kOrdered`, `kWaiter` 열거형으로 전략을 구분.
- `DiningSimulation`
  - 새 필드: `waiter_mutex_`, `waiter_cv_`, `waiter_permits_` (N-1 토큰 관리).
  - `acquireForks`: 철학자 루프에서 전략에 따라 하위 함수 호출.
  - `acquireNaive`: 좌→우 순서, `try_lock_for` 기반 대기 유지.
  - `acquireOrdered`: 포크 인덱스 정렬 후 낮은 번호부터 잠금, 대기 초과 시 재시도.
  - `acquireWaiter`: 웨이터 토큰 획득 후 ordered 방식으로 포크 확보, 종료 시 토큰 반환.
  - `waiterEnter/waiterLeave`: 조건변수로 진입 허용/반환 처리, `stop_requested_` 시 즉시 탈출.
  - `logSummary`: 전략 이름과 식사 횟수 통계를 출력해 테스트와 사용자 확인을 돕는다.
  - 모니터 스레드가 런타임 종료 시 `waiter_cv_`를 깨워 대기 중인 철학자를 종료한다.

## 5. 테스트 전략
- `tests/deadlock_demo.sh`
  - 기본 naive 설정에서 교착 안내 메시지와 요약/종료 로그가 출력되는지 확인.
- `tests/ordered_strategy.sh`
  - ordered 전략 실행 시 교착 메시지가 없어야 하며, 5명의 식사 횟수 요약이 모두 출력되는지 검사.
- `tests/waiter_strategy.sh`
  - waiter 전략 실행 시 교착 메시지가 없어야 하며, 식사 횟수 요약이 5줄 이상인지 확인.
- CTest에 각 스크립트를 등록하여 CI와 로컬 빌드에서 동일하게 검증한다.

## 6. 한계 및 추후 작업
- 식사 횟수는 단순 합산만 제공하므로 v0.3.0에서 대기 시간/분산 등 추가 공정성 지표를 확장한다.
- waiter 전략은 최소한의 토큰 정책만 구현했으므로, 우선순위나 대기 큐를 별도로 두지 않는다.
- 로그는 표준 출력 기준이며, 필요 시 파일/구조화된 포맷(JSON 등)으로 확장할 수 있다.
